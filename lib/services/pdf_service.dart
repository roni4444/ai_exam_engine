import 'dart:io';
import 'package:syncfusion_flutter_pdf/pdf.dart';
import 'package:pdf/pdf.dart' as pw_pdf;
import 'package:pdf/widgets.dart' as pw;
import 'package:flutter/foundation.dart';
import '../models/exam_models.dart';

class PdfService {
  /// Extract text from PDF file
  static Future<String> extractTextFromPdf(File pdfFile) async {
    try {
      final Uint8List bytes = await pdfFile.readAsBytes();
      final PdfDocument document = PdfDocument(inputBytes: bytes);

      final PdfTextExtractor extractor = PdfTextExtractor(document);
      String fullText = extractor.extractText();

      document.dispose();
      return fullText;
    } catch (e) {
      if (kDebugMode) print('PDF text extraction error: $e');
      rethrow;
    }
  }

  /// Extract text from PDF bytes (for web/cross-platform)
  static Future<String> extractTextFromBytes(Uint8List bytes) async {
    try {
      final PdfDocument document = PdfDocument(inputBytes: bytes);
      final PdfTextExtractor extractor = PdfTextExtractor(document);
      String fullText = extractor.extractText();
      document.dispose();
      return fullText;
    } catch (e) {
      if (kDebugMode) print('PDF bytes extraction error: $e');
      rethrow;
    }
  }

  /// Generate exam PDF with questions
  static Future<Uint8List> generateExamPdf({required String examName, required List<Question> questions, String language = 'English'}) async {
    try {
      final pdf = pw.Document();

      // Add cover page
      pdf.addPage(
        pw.Page(
          pageFormat: pw_pdf.PdfPageFormat.a4,
          build: (context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.center,
              mainAxisAlignment: pw.MainAxisAlignment.center,
              children: [
                pw.Text(
                  examName,
                  style: pw.TextStyle(fontSize: 32, fontWeight: pw.FontWeight.bold),
                  textAlign: pw.TextAlign.center,
                ),
                pw.SizedBox(height: 20),
                pw.Text('Generated by AI Exam Engine', style: const pw.TextStyle(fontSize: 14)),
                pw.SizedBox(height: 10),
                pw.Text('Total Questions: ${questions.length}', style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
                pw.Text('Language: $language', style: const pw.TextStyle(fontSize: 14)),
              ],
            );
          },
        ),
      );

      // Group questions by section
      final Map<String, List<Question>> groupedQuestions = {};
      for (var question in questions) {
        if (!groupedQuestions.containsKey(question.sectionName)) {
          groupedQuestions[question.sectionName] = [];
        }
        groupedQuestions[question.sectionName]!.add(question);
      }

      // Add questions
      int questionNumber = 1;
      for (var entry in groupedQuestions.entries) {
        // Section header
        pdf.addPage(
          pw.Page(
            pageFormat: pw_pdf.PdfPageFormat.a4,
            build: (context) {
              return pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Container(
                    width: double.infinity,
                    padding: const pw.EdgeInsets.all(10),
                    decoration: pw.BoxDecoration(
                      color: pw_pdf.PdfColors.blue50,
                      border: pw.Border.all(color: pw_pdf.PdfColors.blue200),
                      borderRadius: const pw.BorderRadius.all(pw.Radius.circular(5)),
                    ),
                    child: pw.Text('Section: ${entry.key}', style: pw.TextStyle(fontSize: 18, fontWeight: pw.FontWeight.bold)),
                  ),
                  pw.SizedBox(height: 20),
                  ...entry.value.map((question) {
                    return pw.Container(
                      margin: const pw.EdgeInsets.only(bottom: 20),
                      child: pw.Column(
                        crossAxisAlignment: pw.CrossAxisAlignment.start,
                        children: [
                          pw.Row(
                            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                            children: [
                              pw.Text('Q${questionNumber++}. ${question.text}', style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
                              pw.Text('[ ${question.marks} Marks ]', style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold)),
                            ],
                          ),
                          if (question.options != null) ...[
                            pw.SizedBox(height: 10),
                            ...question.options!.asMap().entries.map((entry) {
                              return pw.Padding(
                                padding: const pw.EdgeInsets.only(left: 20, bottom: 5),
                                child: pw.Text('${String.fromCharCode(65 + entry.key)}. ${entry.value}', style: const pw.TextStyle(fontSize: 12)),
                              );
                            }),
                          ],
                          pw.SizedBox(height: 10),
                          pw.Row(
                            children: [
                              pw.Container(
                                padding: const pw.EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                decoration: pw.BoxDecoration(
                                  color: pw_pdf.PdfColors.grey200,
                                  borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
                                ),
                                child: pw.Text('Difficulty: ${question.difficulty}', style: const pw.TextStyle(fontSize: 10)),
                              ),
                              pw.SizedBox(width: 10),
                              pw.Container(
                                padding: const pw.EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                decoration: pw.BoxDecoration(
                                  color: pw_pdf.PdfColors.grey200,
                                  borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
                                ),
                                child: pw.Text('Type: ${question.type}', style: const pw.TextStyle(fontSize: 10)),
                              ),
                            ],
                          ),
                        ],
                      ),
                    );
                  }),
                ],
              );
            },
          ),
        );
      }

      return pdf.save();
    } catch (e) {
      if (kDebugMode) print('PDF generation error: $e');
      rethrow;
    }
  }

  /// Generate solution key PDF
  static Future<Uint8List> generateSolutionPdf({
    required String examName,
    required List<Question> questions,
    required Map<String, Map<String, dynamic>> solutions,
    String language = 'English',
  }) async {
    try {
      final pdf = pw.Document();

      // Cover page
      pdf.addPage(
        pw.Page(
          pageFormat: pw_pdf.PdfPageFormat.a4,
          build: (context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.center,
              mainAxisAlignment: pw.MainAxisAlignment.center,
              children: [
                pw.Text(
                  '$examName - Answer Key',
                  style: pw.TextStyle(fontSize: 32, fontWeight: pw.FontWeight.bold),
                  textAlign: pw.TextAlign.center,
                ),
                pw.SizedBox(height: 20),
                pw.Text('Generated by AI Exam Engine', style: const pw.TextStyle(fontSize: 14)),
              ],
            );
          },
        ),
      );

      // Add solutions
      int questionNumber = 1;
      for (var question in questions) {
        final solution = solutions[question.id];
        if (solution == null) continue;

        pdf.addPage(
          pw.Page(
            pageFormat: pw_pdf.PdfPageFormat.a4,
            build: (context) {
              return pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Text('Q${questionNumber++}. ${question.text}', style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
                  pw.SizedBox(height: 15),
                  pw.Container(
                    padding: const pw.EdgeInsets.all(10),
                    decoration: pw.BoxDecoration(
                      color: pw_pdf.PdfColors.green50,
                      border: pw.Border.all(color: pw_pdf.PdfColors.green200),
                      borderRadius: const pw.BorderRadius.all(pw.Radius.circular(5)),
                    ),
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text('Model Answer:', style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold)),
                        pw.SizedBox(height: 5),
                        pw.Text(solution['answer'] ?? question.modelAnswer, style: const pw.TextStyle(fontSize: 12)),
                      ],
                    ),
                  ),
                  pw.SizedBox(height: 10),
                  pw.Text('Rubric Points:', style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold)),
                  pw.SizedBox(height: 5),
                  ...question.rubric.map((point) {
                    return pw.Padding(
                      padding: const pw.EdgeInsets.only(left: 10, bottom: 3),
                      child: pw.Row(
                        children: [
                          pw.Text('â€¢ ', style: const pw.TextStyle(fontSize: 12)),
                          pw.Expanded(child: pw.Text(point, style: const pw.TextStyle(fontSize: 11))),
                        ],
                      ),
                    );
                  }),
                ],
              );
            },
          ),
        );
      }

      return pdf.save();
    } catch (e) {
      if (kDebugMode) print('Solution PDF generation error: $e');
      rethrow;
    }
  }

  /*/// Convert PDF to images for vision analysis
  static Future<List<Uint8List>> pdfToImages(File pdfFile) async {
    try {
      final Uint8List bytes = await pdfFile.readAsBytes();
      final PdfDocument document = PdfDocument(inputBytes: bytes);

      List<Uint8List> images = [];

      for (int i = 0; i < document.pages.count; i++) {
        final PdfPage page = document.pages[i];
        final Uint8List imageBytes = await page.render();
        images.add(imageBytes);
      }

      document.dispose();
      return images;
    } catch (e) {
      if (kDebugMode) print('PDF to image conversion error: $e');
      rethrow;
    }
  }*/

  /* Future<String> extractTextFromPdf(Uint8List bytes) async {
    // Note: Flutter doesn't have a direct equivalent to pdfjs
    // You'll need to use a package like pdf or implement native code
    // For now, returning a placeholder
    // TODO: Implement actual PDF text extraction
    return 'Extracted text from PDF';
  }

  Future<void> generatePdf(String content, String fileName) async {
    final pdf = pw.Document();

    pdf.addPage(pw.Page(build: (context) => pw.Center(child: pw.Text(content))));

    await Printing.sharePdf(bytes: await pdf.save(), filename: fileName);
  }*/
}
